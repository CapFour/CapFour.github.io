<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://capfour.github.io/</id>
    <title>FEfour的笔记</title>
    <updated>2021-07-07T03:35:53.970Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://capfour.github.io/"/>
    <link rel="self" href="https://capfour.github.io/atom.xml"/>
    <subtitle>FEfour的笔记</subtitle>
    <logo>https://capfour.github.io/images/avatar.png</logo>
    <icon>https://capfour.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, FEfour的笔记</rights>
    <entry>
        <title type="html"><![CDATA[手动实现call(), apply(), bind()]]></title>
        <id>https://capfour.github.io/post/shou-dong-shi-xian-call-apply-bind/</id>
        <link href="https://capfour.github.io/post/shou-dong-shi-xian-call-apply-bind/">
        </link>
        <updated>2021-07-07T02:33:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-call-apply-bind-其作用都是改变函数运行时this的指向">一、call、apply、bind 其作用都是改变函数运行时this的指向</h2>
<pre><code>1, call 的参数是直接放进去的，用逗号分隔   
2, apply 的所有参数都必须放在一个数组里面传进去  
3, bind 除了返回是函数以外，它的参数和 call 一样；与上面两者不同的是bind不会立即执行函数，而call和apply会执行函数
</code></pre>
<h2 id="二-手动实现三个函数">二、手动实现三个函数</h2>
<h2 id="1-知识点">1、知识点</h2>
<pre><code>1、实际上，每个 JavaScript 函数都是一个 Function 对象
console.log((function(){}).constructor === Function)
2、自定义一个全局方法可以在Function.prototype上定义一个方法
</code></pre>
<h2 id="2-call">2、call</h2>
<pre><code>Function.prototype.myCall = function (context) {
    //调用对象校验
    if (typeof this !== 'function') {
        console.log(&quot;type error&quot;);
    }
    //this指向默认window
    context = context || window

    //获取参数
    let args = [...arguments].slice(1)

    context.fn = this
    const result = context.fn(...args)
    delete context.fn
    return result
}
</code></pre>
<h2 id="3-apply">3, apply</h2>
<pre><code>Function.prototype.myApply = function (context) {
     //调用对象校验
    if(typeof this !== 'function') {
        throw new TypeError('error')
    }
    let result = null
   //this指向默认window
    context = context || window
    // 把当前调用的函数赋值给传入对象的
    // context.fn 可以理解为： context.prototype.
    context.fn = this
    if (arguments[1]) {
        result = context.fn([...arguments[1]]) // 调用赋值的函数
    }
    delete context.fn
    return result
}
</code></pre>
<h2 id="4-bind">4、bind</h2>
<pre><code>Function.prototype.myBind = function(context) {
    if (typeof this !== 'function') {
        throw new TypeError('error')
    }
    // 获取参数
    let args = [...arguments].slice(1) // 第一个是对象
    context.fn = this // 调用对象
    return function Fn() {
            return fn.apply(this instanceof Fn ? this : context, args.concat(...arguments)) }
}
</code></pre>
<h2 id="三-总结">三, 总结</h2>
<pre><code>bind和call与apply的区别是不会立即调用函数，常用于改变回调函数的参数，bind的参数传递方式和call一样
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[webpack定制前端开发环境]]></title>
        <id>https://capfour.github.io/post/webpack-ding-zhi-qian-duan-kai-fa-huan-jing/</id>
        <link href="https://capfour.github.io/post/webpack-ding-zhi-qian-duan-kai-fa-huan-jing/">
        </link>
        <updated>2021-07-06T09:15:47.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="基础概念">基础概念</h2>
<p>webpack 本质上是一个打包工具，它会根据代码的内容解析模块依赖，帮助开发者把多个模块的代码进行打包。<br>
<img src="https://capfour.github.io//post-images/1625563328722.png" alt="" loading="lazy"></p>
<h2 id="核心概念">核心概念</h2>
<h3 id="entry"><strong>entry</strong></h3>
<p>如上图所示，在多个代码模块中会有一个起始的 .js 文件，这个便是 webpack 构建的入口，即 entry。webpack 会读取这个文件，并从它开始解析依赖，在内部构件一个依赖图，这个依赖图会引用项目中使用到的各个模块，然后进行打包，生成一个或者多个 bundle 文件。</p>
<p>入口可以使用 entry 字段来进行配置：</p>
<pre><code>module.exports = {
    entry: './src/index.js' 
}

// 上述配置等同于
module.exports = {
    entry: {
        main: './src/index.js'
    }
}
</code></pre>
<h3 id="output"><strong>output</strong></h3>
<p>webpack 的输出即指 webpack 最终构建出来的静态文件，可以看看上面 webpack 官方图片右侧的那些文件。当然，webpack 构建生成的文件名、路径等都是可以配置的，在配置文件中使用 output 字段来进行设置：</p>
<pre><code>module.exports = {
    //......
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js',
    },
}

// 或者使用 entry 的名称
module.exports = {
    entry: {
        main: './src/index.js' // main 为 entry 的名称
    },
    output: {
        filename: '[name].js', // 使用 [name] 来引用 entry 名称，在这里即为 main
        path: path.join(__dirname, '/dist/[hash]'),
            // 路径中使用 hash，每次构建时会有一个不同 hash 值，可以用于避免发布新版本时浏览器存             导致代码没有更新
            // 文件名中也可以使用 hash
        },
}
</code></pre>
<p>我们一开始直接使用 webpack 构建时，默认创建的输出内容就是 ./dist/main.js。</p>
<h3 id="loader"><strong>loader</strong></h3>
<p>我们在前端构建中会遇见需要使用各式各样的文件，例如 css 代码，图片，模板代码等。webpack 中提供一种处理多种文件格式的机制，便是使用 loader。我们可以把 loader 理解为是一个转换器，负责把某种文件格式的内容转换成 webpack 可以支持打包的模块。</p>
<p>举个例子，在没有添加额外插件的情况下，webpack 会默认把所有依赖打包成 js 文件，如果入口文件依赖一个 .hbs 的模板文件以及一个 .css 的样式文件，那么我们需要 handlebars-loader 来处理 .hbs 文件，需要 css-loader 来处理 .css 文件（这里其实还需要 style-loader，后续详解），最终把不同格式的文件都解析成 js 代码，以便打包后在浏览器中运行。</p>
<p>当我们需要使用不同的 loader 来解析处理不同类型的文件时，我们可以在 module.rules 字段下来配置相关的规则，例如使用 Babel 来处理 .js 文件：</p>
<pre><code>module.exports = {
    //......
    module: {
            rules: [
                {
                    test: /\.css/,
                    include: [
                        path.resolve(__dirname, 'src'),
                    ],
                    use: [
                        MiniCssExtractPlugin.loader,
                        'css-loader',
                    ],
                }
            ]
    },
}
</code></pre>
<h3 id="plugin"><strong>plugin</strong></h3>
<p>在 webpack 的构建流程中，plugin 用于处理更多其他的一些构建任务。可以这么理解，模块代码转换的工作由 loader 来处理，除此之外的其他任何工作都可以交由 plugin 来完成。通过添加我们需要的 plugin，可以满足更多构建中特殊的需求。例如，使用 copy-webpack-plugin 来复制其他不需要 loader 处理的文件，只需在配置中通过 plugins 字段添加新的 plugin 即可：</p>
<pre><code>npm install copy-webpack-plugin -D
</code></pre>
<p>插件通常为第三方的 npm package，都需要安装后才能使用</p>
<pre><code>const CopyPlugin = require('copy-webpack-plugin');

module.exports = {
// ...

plugins: [
    new CopyPlugin([
    { from: 'src/public', to: 'public' },
    ]),
],
};
</code></pre>
<p>plugin 理论上可以干涉 webpack 整个构建流程，可以在流程的每一个步骤中定制自己的构建需求。继续深<br>
入 webpack 配置之后，我们会介绍如何开发 plugin，让读者们在必要时，也可以在 webpack 的基础上开发 plugin 来应对一些项目的特殊构建需求。</p>
]]></content>
    </entry>
</feed>