<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://capfour.github.io/</id>
    <title>FEfour的笔记</title>
    <updated>2021-07-29T03:31:52.372Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://capfour.github.io/"/>
    <link rel="self" href="https://capfour.github.io/atom.xml"/>
    <subtitle>FEfour的笔记</subtitle>
    <logo>https://capfour.github.io/images/avatar.png</logo>
    <icon>https://capfour.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, FEfour的笔记</rights>
    <entry>
        <title type="html"><![CDATA[Promise浅析与自定义]]></title>
        <id>https://capfour.github.io/post/promise-qian-xi-yu-zi-ding-yi/</id>
        <link href="https://capfour.github.io/post/promise-qian-xi-yu-zi-ding-yi/">
        </link>
        <updated>2021-07-28T07:39:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-准备">1. 准备</h2>
<h3 id="11-实例对象与函数对象">1.1 实例对象与函数对象</h3>
<ul>
<li>实例对象：new产生的对象，称为实例对象，简称对象</li>
<li>函数对象：将函数作为对象使用时，简称为函数对象</li>
<li>实例对象简称对象，函数对象不能简称为对象</li>
<li>可以认为()左边的函数，.左边的是对象</li>
<li>所以既可以在()前面又可以.前面的就是函数对象</li>
</ul>
<pre><code class="language-js">function Fn() { // 仅仅在这一步，此时不能说Fn是一个构造函数，只有new之后才能说为构造函数
}
const fn = new Fn() // 此时的Fn是构造函数，fn是实例对象(简称对象)
console.log(Fn.prototype) // Fn为函数对象
Fn.call({}) // Fn为函数对象
$('#id') // 此时$成jQuery函数
$.get('./test') // 此时的$称jQuery函数对象
</code></pre>
<p>原文链接：https://blog.csdn.net/weixin_43760969/article/details/108500756</p>
<h3 id="12-两种类型的毁掉函数">1.2 两种类型的毁掉函数</h3>
<h4 id="121-同步回调">1.2.1 同步回调</h4>
<ul>
<li>理解：立即执行，完全执行完了才结束，不会放入回调队列中</li>
<li>例子：数组遍历相关的回调函数、Promise的excutor函数</li>
</ul>
<h4 id="122-异步回调">1.2.2 异步回调</h4>
<ul>
<li>理解：不会立刻执行，会放入回调队列中将来执行</li>
<li>例子：定时器回调、ajax回调、Promise的成功｜失败的回调</li>
</ul>
<pre><code class="language-js">const arr = [1,2,3]
arr.forEach(item=&gt;console.log(item)) // 同步回调，不会放入回调队列，而是立即执行
console.log(&quot;forEach()之后&quot;)
setTimeout(()=&gt;{ // 异步回调，会放入回调队列中，所有同步执行完后才可能执行
    console.log('timeout回调')
}，0)
console.log('setTimeout之后')
</code></pre>
<h2 id="2-promise-的理解与使用">2 promise 的理解与使用</h2>
<h3 id="21-什么是promise">2.1 什么是Promise</h3>
<h4 id="211-理解">2.1.1 理解</h4>
<ul>
<li>抽象：Promise是JS中进行异步编程的新的解决方案（灵魂拷问：旧的是啥？）</li>
<li>具体：
<ul>
<li>语法上：Promise是一个构造函数</li>
<li>功能上：promise对象被用来封装一个异步操作并可以获取其结果</li>
</ul>
</li>
</ul>
<h4 id="212-promise的状态改变">2.1.2 promise的状态改变</h4>
<ul>
<li>pending --&gt; resolved</li>
<li>pending --&gt; rejected<br>
<code>说明：只存在这两种，并且一个promise对象的状态只能改变一次，无论成功或失败都会返回一个结果；一般来说成功的结果为value，失败的结果为reason</code></li>
</ul>
<h4 id="212-promise-的基本流程">2.1.2 promise 的基本流程</h4>
<figure data-type="image" tabindex="1"><img src="https://capfour.github.io//post-images/1627461170625.png" alt="" loading="lazy"></figure>
<h4 id="212-promise-的基本使用">2.1.2 promise 的基本使用</h4>
<pre><code class="language-js">//1.创建promise对象
const p = new Promise((resolve,reject) =&gt; {
    //执行异步操作
    setTimeout(() =&gt; {
        const time = Data.now() //假设当前时间是奇数表示成功，偶数表示失败
        //如果成功，调用resolve(value)
        if(time%2 === 1){
            resolve(`成功的结果${time}`)
        }else{
        //如果失败，调用reject(reason)
            reject(`失败的结果${time}`)
        }
    },1000)
})
//2.通过promise的then()指定成功和失败的回调函数
p.then(
    value =&gt; {
        console.log('成功的回调，value：'，value)
    },
    reason =&gt; {
        console.log('失败的回调，reason：', reason)
    }
)
</code></pre>
<h3 id="22-为什么要用promise">2.2 为什么要用Promise？</h3>
<h4 id="221-指定回调函数的方式更加灵活">2.2.1 指定回调函数的方式更加灵活</h4>
<ul>
<li>旧的：必须在启动异步任务前指定</li>
<li>promise：启动异步任务 =&gt; 返回promise对象 =&gt; 给promise对象绑定回调函数（甚至可以在异步任务结束后指定/多个）</li>
</ul>
<h4 id="222-支持链式调用-可以解决回调地狱问题">2.2.2 支持链式调用, 可以解决回调地狱问题</h4>
<ul>
<li>什么是回调地狱？
<ul>
<li>回调函数的嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件（此处自行脑补下俄罗斯套娃）</li>
</ul>
</li>
<li>回调地狱的缺点？
<ul>
<li>不便于阅读</li>
<li>不便于异常处理</li>
</ul>
</li>
<li>解决方案？
<ul>
<li>promise的链式调用</li>
</ul>
</li>
<li>终极解决方案
<ul>
<li>async/await</li>
</ul>
</li>
<li>上代码</li>
</ul>
<pre><code class="language-js">&lt;script&gt;
    // 成功的回调函数 
    successCallback(result) { console.log(&quot;声音文件创建成功: &quot; + result); }
    // 失败的回调函数 
    failureCallback(error) { console.log(&quot;声音文件创建失败: &quot; + error); }

    /* 1.1 使用纯回调函数 */ 
    createAudioFileAsync(audioSettings, successCallback, failureCallback)

    /* 1.2. 使用 Promise */ 
    const promise = createAudioFileAsync(audioSettings); // 2 
    setTimeout(() =&gt; { 
        promise.then(successCallback, failureCallback); 
    }, 3000);

    /*2.1. 回调地狱 */
    doSomething(function(result) {
        doSomethingElse(result, function(newResult) {
            doThirdThing(newResult, function(finalResult) {
                console.log('Got the final result: ' + finalResult) 
            }, failureCallback)
        }, failureCallback)
    }, failureCallback) 

    /*2.2. 使用 promise 的链式调用解决回调地狱 */
    doSomething().then(function(result) {
        return doSomethingElse(result) 
    })
    .then(function(newResult) { 
        return doThirdThing(newResult) 
    })
    .then(function(finalResult) {
        console.log('Got the final result: ' + finalResult)
    })
    .catch(failureCallback) 
    
    /*2.3. async/await: 回调地狱的终极解决方案 */
    async function request() { 
        try { 
            const result = await doSomething() 
            const newResult = await doSomethingElse(result) 
            const finalResult = await doThirdThing(newResult) 
            console.log('Got the final result: ' + finalResult) 
        } catch (error) {
            failureCallback(error) 
        }
    } 
&lt;/script&gt;
</code></pre>
<h3 id="23-如何使用-promise">2.3 如何使用 Promise?</h3>
<h4 id="231-api">2.3.1 API</h4>
<ul>
<li>
<p>Promise 构造函数：Promise(excutor){}</p>
<ul>
<li>excutor 函数：执行器 （resolve, reject）=&gt; {}</li>
<li>resolve 函数：内部定义为成功时我们调用的函数 value =&gt; {}</li>
<li>reject 函数: 内部定义为失败时我们调用的函数 reason =&gt; {}</li>
<li><code>说明: excutor 会在 Promise 内部立即同步回调,异步操作在执行器中执行</code></li>
</ul>
</li>
<li>
<p>Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {}</p>
<ul>
<li>onResolved 函数: 成功的回调函数 (value) =&gt; {}</li>
<li>onRejected 函数: 失败的回调函数 (reason) =&gt; {}</li>
<li><code>指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调 返回一个新的 promise 对象</code></li>
</ul>
</li>
<li>
<p>Promise.prototype.catch 方法: (onRejected) =&gt; {} (1) onRejected 函数: 失败的回调函数 (reason) =&gt; {} 说明: then()的语法糖, 相当于: then(undefined, onRejected)</p>
</li>
<li>
<p>Promise.resolve 方法: (value) =&gt; {} (1) value: 成功的数据或 promise 对象 说明: 返回一个成功/失败的 promise 对象</p>
</li>
<li>
<p>Promise.reject 方法: (reason) =&gt; {} (1) reason: 失败的原因 说明: 返回一个失败的 promise 对象</p>
</li>
<li>
<p>Promise.all 方法: (promises) =&gt; {} (1) promises: 包含 n 个 promise 的数组 说明: 返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一个失败了就 直接失败</p>
</li>
<li>
<p>Promise.race 方法: (promises) =&gt; {} (1) promises: 包含 n 个 promise 的数组 说明: 返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态</p>
</li>
</ul>
<h4 id="232-promise-的几个关键问题">2.3.2 promise 的几个关键问题</h4>
<ul>
<li>
<p>如何改变 promise 的状态?</p>
<ul>
<li>resolve(value): 如果当前是 pendding 就会变为 resolved</li>
<li>reject(reason): 如果当前是 pendding 就会变为 rejected</li>
<li>抛出异常: 如果当前是 pendding 就会变为 rejected</li>
</ul>
</li>
<li>
<p>一个 promise 指定多个成功/失败回调函数, 都会调用吗?</p>
<ul>
<li>当 promise 改变为对应状态时都会调用</li>
</ul>
</li>
<li>
<p>改变 promise 状态和指定回调函数谁先谁后?</p>
<ul>
<li>都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调</li>
<li>如何先改状态再指定回调?
<ul>
<li>在执行器中直接调用 resolve()/reject()</li>
<li>延迟更长时间才调用 then()</li>
</ul>
</li>
<li>什么时候才能得到数据?
<ul>
<li>如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据</li>
<li>如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据</li>
</ul>
</li>
</ul>
</li>
<li>
<p>promise.then()返回的新 promise 的结果状态由什么决定?</p>
<ul>
<li>简单表达: 由 then()指定的回调函数执行的结果决定</li>
<li>详细表达:
<ul>
<li>如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常</li>
<li>如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值</li>
<li>如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</li>
</ul>
</li>
</ul>
</li>
<li>
<p>promise 如何串连多个操作任务?</p>
<ul>
<li>promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用</li>
<li>通过 then 的链式调用串连多个同步/异步任务</li>
</ul>
</li>
<li>
<p>promise 异常传透?</p>
<ul>
<li>当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调,</li>
<li>前面任何操作出了异常, 都会传到最后失败的回调中处理</li>
</ul>
</li>
<li>
<p>中断 promise 链?</p>
<ul>
<li>当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数</li>
<li>办法: 在回调函数中返回一个 pendding 状态的 promise 对象</li>
</ul>
<h2 id="3-自定义手写promise">3. 自定义（手写）Promise</h2>
<h3 id="31-准备">3.1 准备</h3>
<p><code>*可以用Promise构造函数和Promise类两种方式，此处采用Promise类，顺便复习下需要用到的类的知识</code></p>
</li>
<li>
<p>javaScript中，传统的生成实例对象的方法是用构造函数。如下：</p>
</li>
</ul>
<pre><code class="language-js">function Person (name, age) {
    this.name = name
    this.age = age
}
Person.prototype.sayHello = function () {
    return `你好！我是${this.name}，今年${this.age}岁`
}
let person = new Person('张三',18)
</code></pre>
<ul>
<li>ES6引入了 Class（类）的概念，作为对象的模板。通过 <code>class</code> 关键字，可以定义类。基本上,可以把<code>class</code>看作是一个语法糖，绝大多部分的功能ES5都可以做到，只是<code>class</code>会让原型对象的写法显得更加清晰。上面的代码改写成<code>class</code>,如下：</li>
</ul>
<pre><code class="language-js">class Person {
    //constructor是构造方法，里面的this代表实例对象，相当于ES5的构造函数，在new的时候会调用
    constructor(name,age){
        this.name = name
        this.age = age
    }
    //此处定义的方法实际是定义在类的prototype属性上的
    sayHello(){
         return `你好！我是${this.name}，今年${this.age}岁`
    }
}
let person = new Person('张三',18)
</code></pre>
<ul>
<li>静态方法：类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”</li>
</ul>
<pre><code class="language-js">class Person {
   static sayHello(){
         return 'hello'
    }
}
Person.sayHello() // 'hello'
let p = new Person()
p.hello() //TypeError: p.hello is not a function
</code></pre>
<p><code>注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。</code></p>
<ul>
<li>class还有其他一些知识点，但以上基本可以理解下面代码</li>
</ul>
<h3 id="32-上代码">3.2 上代码</h3>
<pre><code class="language-js">class Promise {
    //executor：内部同步执行的函数 （resolve,reject）=&gt; {}
    constructor(executor) {
        this.PromiseStatus = 'pending' //状态值，初始状态为pending，成功了变为fulfilled，失败变为rejected
        this.PromiseResult = null //用来保存成功或者失败的结果
        this.callback = [] //用来保存所有待调用的包含onResolve和onReject回调函数的对象的数组
        const _this = this
        /*
        异步处理成功后应该调用的函数
        data：将交给onResolve()的成功数据
        */ 
        function resolve(data) {
            //如果当前状态不是pending，直接结束
            if (_this.PromiseStatus !== 'pending') return; 
            // 更新状态，保存数据
            _this.PromiseStatus = 'fulfilled'
            _this.PromiseResult = data
            //异步调用所有待处理的onResolve成功回调函数
            if(_this.callback.length &gt; 0){
                setTimeout(() =&gt; {
                    _this.callback.forEach(item =&gt; {
                        item.onResolve(data)
                    })
                })
            }
        }
        /*
        异步处理失败后应该调用的函数
        data：将交给onReject()的失败数据
        */ 
        function reject(data) {
            //如果当前状态不是pending，直接结束
            if (_this.PromiseStatus !== 'pending') return
            // 更新状态，保存数据
            _this.PromiseStatus = 'rejected'
            _this.PromiseResult = data
            //异步调用所有待处理的onReject失败回调函数
            if(_this.callback.length &gt; 0){
                setTimeout(() =&gt; {
                    _this.callback.forEach(item =&gt; {
                        item.onReject(data)
                    })
                })
            }
        }
        try {
            //同步调用executor()处理
            executor(resolve, reject)
        } catch (error) { //如果出了异常，直接失败
            reject(error)
        }
    }
    /*
     为promise指定成功/失败的回调函数
     函数的返回值是一个新的promise对象
    */ 
    then(onResolve, onReject) {
        const _this = this
        //返回的是一个promise对象
        return new Promise((resolve, reject) =&gt; {
            function callback(type) {
                try {
                    let result = type(_this.PromiseResult)
                    //如果当前结果是一个Promise对象就以成功返回，反之以失败返回
                    if (result instanceof Promise) {
                        result.then(v =&gt; {
                            resolve(v)
                        }, r =&gt; {
                            reject(r)
                        })
                    } else {
                        resolve(result)
                    }
                //出错直接以失败返回
                } catch (error) {
                    reject(error)
                }
            }

            if (this.PromiseStatus === 'fulfilled') {
                setTimeout(() =&gt; {
                    callback(onResolve)
                })
            }

            if (this.PromiseStatus === 'rejected') {
                if (typeof onReject !== 'function') {
                    onReject = reason =&gt; {
                        throw reason
                    }
                }
                setTimeout(() =&gt; {
                    callback(onReject)
                })
            }

            if (this.PromiseStatus === 'pending') {
                this.callback.push(
                    {
                        onResolve: function () {
                            callback(onResolve)
                        },
                        onReject: function () {
                            callback(onReject)
                        }
                    }
                )
            }
        })
    }
    catch(onReject) {
        return this.then(undefined, onReject)
    }
    
    static resolve(value) {
        return new Promise((resolve, reject) =&gt; {
            if (value instanceof Promise) {
                value.then(v =&gt; {
                    resolve(v)
                }, r =&gt; {
                    reject(r)
                })
            } else {
                resolve(value)
            }
        })
    }

    static all(promises) {
        let count = 0, arr = [];
        return new Promise((resolve, reject) =&gt; {
            for (let i = 0; i &lt; promises.length; i++) {
                promises[i].then(v =&gt; {
                    count++;
                    arr[i] = v
                    if (count === promises.length) {
                        resolve(arr)
                    }
                }, r =&gt; {
                    reject(r)
                })
            }
        })
    }

    static race(promises) {
        return new Promise((resolve, reject) =&gt; {
            for (let i = 0; i &lt; promises.length; i++) {
                promises[i].then(v =&gt; {
                    resolve(v)
                }, r =&gt; {
                    reject(r)
                })
            }
        })
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[自定义工具库]]></title>
        <id>https://capfour.github.io/post/zi-ding-yi-gong-ju-ku/</id>
        <link href="https://capfour.github.io/post/zi-ding-yi-gong-ju-ku/">
        </link>
        <updated>2021-07-28T01:30:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-创建工具包项目"><strong>1. 创建工具包项目</strong></h2>
<h3 id="11-安装node">1.1 安装node</h3>
<ul>
<li>检查是否安装node（node中自带npm）<br>
<img src="https://capfour.github.io//post-images/1627436045461.png" alt="" loading="lazy"></li>
<li>如果node与npm命令不识别，请自行安装</li>
</ul>
<h3 id="12-创建项目">1.2 创建项目</h3>
<pre><code class="language-bash"># 创建一个空的项目文件夹: yuzhilin-utils
# 在文件夹下执行命令
npm init -y
</code></pre>
<h3 id="13-下载依赖包">1.3 下载依赖包</h3>
<pre><code class="language-bash">npm i webpack webpack-cli
</code></pre>
<h3 id="14配置webpack">1.4.配置webpack</h3>
<ul>
<li><code>webpack.config.js</code></li>
</ul>
<pre><code class="language-js">const path = require('path')
module.exports = {
  // 模式
  mode: 'development', // 也可以使用 production
  // 入口
  entry: './src/index.js', 
  // 出口
  output: {
    // 打包文件夹
    path: path.resolve(__dirname, 'dist'),
    // 打包文件
    filename: 'yuzhilin-utils.js', 
    // 向外暴露的对象的名称
    library: 'yUtils',
    // 打包生成库可以通过esm/commonjs/reqirejs的语法引入
    libraryTarget: 'umd', 
  },
}
</code></pre>
<h3 id="15在入口js中暴露功能">1.5.在入口JS中暴露功能</h3>
<ul>
<li><code>src/index.js</code></li>
</ul>
<pre><code class="language-js">export function test() {
  document.write('测试自定义包')
  console.log('test()')
}
</code></pre>
<h3 id="16配置打包命令">1.6.配置打包命令</h3>
<ul>
<li><code>packge.json</code></li>
</ul>
<pre><code class="language-json">&quot;scripts&quot;: {
  &quot;build:watch&quot;: &quot;webpack --watch&quot;
},
</code></pre>
<h3 id="17对项目进行打包">1.7.对项目进行打包</h3>
<pre><code class="language-bash">npm run build:watch
</code></pre>
<h3 id="18测试使用自定义包">1.8.测试使用自定义包</h3>
<ul>
<li><code>test/first.html</code></li>
</ul>
<pre><code class="language-html">&lt;body&gt;
  &lt;script src=&quot;../dist/yuzhilin-utils.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    yUtils.test()
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://capfour.github.io//post-images/1627437322386.png" alt="" loading="lazy"></figure>
<h2 id="2-发布到npm中央仓库"><strong>2. 发布到npm中央仓库</strong></h2>
<h3 id="21完善-packagejson">2.1.完善 package.json</h3>
<ul>
<li>注意：
<ul>
<li>name：必须是唯一的名称（npm线上中央仓库没有重复的名称）</li>
<li>mian：必须指定为打包生成的js文件</li>
<li>keywords：制定一些方便其他开发人员搜索当前库的关键字</li>
</ul>
</li>
</ul>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;utils&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;author&quot;: &quot;yuzhilin&quot;,
  &quot;description&quot;: &quot;yuzhilin-前端-自定义工具函数库&quot;,
  &quot;keywords&quot;: [
    &quot;yuzhilin&quot;,
    &quot;utils&quot;,
    &quot;array&quot;,
    &quot;object&quot;,
    &quot;function&quot;,
    &quot;string&quot;,
    &quot;axios&quot;,
    &quot;event-bus&quot;,
    &quot;pub-sub&quot;,
    &quot;promise&quot;
  ],
  &quot;main&quot;: &quot;dist/yuzhilin-utils.js&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;scripts&quot;: {
    &quot;build:watch&quot;: &quot;webpack --watch&quot;,
    &quot;build&quot;: &quot;webpack&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;webpack&quot;: &quot;^5.10.0&quot;,
    &quot;webpack-cli&quot;: &quot;^4.2.0&quot;
  }
}
</code></pre>
<h3 id="22npm配置">2.2.npm配置</h3>
<ul>
<li>npm配置的中央仓库不能是淘宝镜像</li>
<li>发布前必须执行: npm config set registry https://registry.npmjs.org/</li>
<li>不用发布时: npm config set registry http://registry.npm.taobao.org/</li>
<li>查看配置: npm config list</li>
</ul>
<h3 id="23注册npm中央仓库账号">2.3.注册npm中央仓库账号</h3>
<ul>
<li>注册地址: https://www.npmjs.com/</li>
<li>关键信息: 用户名/密码/邮箱(需要验证)<br>
<img src="https://capfour.github.io//post-images/1627437892691.jpg" alt="" loading="lazy"></li>
</ul>
<h3 id="24添加用户">2.4.添加用户</h3>
<ul>
<li>执行: npm addUser</li>
<li>登陆npm仓库</li>
<li>依次指定用户名/密码/邮箱<br>
<img src="https://capfour.github.io//post-images/1627438226545.png" alt="" loading="lazy"></li>
</ul>
<h3 id="25发布仓库">2.5.发布仓库</h3>
<ul>
<li>执行npm publish<br>
<img src="https://capfour.github.io//post-images/1627438509682.png" alt="" loading="lazy"></li>
<li>发布失败（可能的两个原因：1、存在其他同名库，2、自己已经发布过同名库），修改一下package.json中的name为一个唯一值，在发布<br>
<img src="https://capfour.github.io//post-images/1627438733957.png" alt="" loading="lazy"></li>
</ul>
<h3 id="26更新代码后发布">2.6.更新代码后发布</h3>
<ul>
<li>修改项目库的版本号: package.json 中的version 从1.0.0 改为1.0.1, 注意一定要变大</li>
<li>修改代码后重新打包: npm run build</li>
<li>执行发布: npm publish</li>
</ul>
<h3 id="27强制删除已发布的库">2.7.强制删除已发布的库</h3>
<ul>
<li>执行: npm unpublish --force</li>
<li>注意: 必须在72小时内, 否则不能再删除</li>
</ul>
<h2 id="3使用自定义工具包"><strong>3.使用自定义工具包</strong></h2>
<h3 id="31下载工具包">3.1.下载工具包</h3>
<pre><code class="language-bash"># 名称是你前面指定的库的名称
npm install y-utils2
</code></pre>
<h3 id="32网页中引入并使用">3.2.网页中引入并使用</h3>
<pre><code class="language-html">&lt;script src=&quot;./node_modules/y-utils2/dist/yuzhilin-utils.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  yUtils.test()
&lt;/script&gt;
</code></pre>
<h3 id="33模块化引入并使用">3.3.模块化引入并使用</h3>
<pre><code class="language-js">// 使用ESM引入
import {test} from 'y-utils2'
test()

// 使用commonjs引入
const {test} = require('y-utils2')
test()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue3快速上手]]></title>
        <id>https://capfour.github.io/post/vue3-kuai-su-shang-shou/</id>
        <link href="https://capfour.github.io/post/vue3-kuai-su-shang-shou/">
        </link>
        <updated>2021-07-27T09:15:42.000Z</updated>
        <content type="html"><![CDATA[<img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" />
<h2 id="1vue3简介">1.Vue3简介</h2>
<ul>
<li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li>
<li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is%3Apr+is%3Amerged+-author%3Aapp%2Fdependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a></li>
<li>github上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0</li>
</ul>
<h2 id="2vue3带来了什么">2.Vue3带来了什么</h2>
<h3 id="1性能的提升">1.性能的提升</h3>
<ul>
<li>
<p>打包大小减少41%</p>
</li>
<li>
<p>初次渲染快55%, 更新渲染快133%</p>
</li>
<li>
<p>内存减少54%</p>
<p>......</p>
</li>
</ul>
<h3 id="2源码的升级">2.源码的升级</h3>
<ul>
<li>
<p>使用Proxy代替defineProperty实现响应式</p>
</li>
<li>
<p>重写虚拟DOM的实现和Tree-Shaking</p>
<p>......</p>
</li>
</ul>
<h3 id="3拥抱typescript">3.拥抱TypeScript</h3>
<ul>
<li>Vue3可以更好的支持TypeScript</li>
</ul>
<h3 id="4新的特性">4.新的特性</h3>
<ol>
<li>
<p>Composition API（组合API）</p>
<ul>
<li>setup配置</li>
<li>ref与reactive</li>
<li>watch与watchEffect</li>
<li>provide与inject</li>
<li>......</li>
</ul>
</li>
<li>
<p>新的内置组件</p>
<ul>
<li>Fragment</li>
<li>Teleport</li>
<li>Suspense</li>
</ul>
</li>
<li>
<p>其他改变</p>
<ul>
<li>新的生命周期钩子</li>
<li>data 选项应始终被声明为一个函数</li>
<li>移除keyCode支持作为 v-on 的修饰符</li>
<li>......</li>
</ul>
</li>
</ol>
<h1 id="一-创建vue30工程">一、创建Vue3.0工程</h1>
<h2 id="1使用-vue-cli-创建">1.使用 vue-cli 创建</h2>
<p>官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</p>
<pre><code class="language-bash">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上
vue --version
## 安装或者升级你的@vue/cli
npm install -g @vue/cli
## 创建
vue create vue_test
## 启动
cd vue_test
npm run serve
</code></pre>
<h2 id="2使用-vite-创建">2.使用 vite 创建</h2>
<p>官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite</p>
<p>vite官网：https://vitejs.cn</p>
<ul>
<li>什么是vite？—— 新一代前端构建工具。</li>
<li>优势如下：
<ul>
<li>开发环境中，无需打包操作，可快速的冷启动。</li>
<li>轻量快速的热重载（HMR）。</li>
<li>真正的按需编译，不再等待整个应用编译完成。</li>
</ul>
</li>
<li>传统构建 与 vite构建对比图</li>
</ul>
<p><img src="https://cn.vitejs.dev/assets/bundler.37740380.png" style="width:500px;height:280px;float:left" /><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" style="width:480px;height:280px" /></p>
<pre><code class="language-bash">## 创建工程
npm init vite-app &lt;project-name&gt;
## 进入工程目录
cd &lt;project-name&gt;
## 安装依赖
npm install
## 运行
npm run dev
</code></pre>
<h1 id="二-常用-composition-api">二、常用 Composition API</h1>
<p>官方文档: https://v3.cn.vuejs.org/guide/composition-api-introduction.html</p>
<h2 id="1拉开序幕的setup">1.拉开序幕的setup</h2>
<ol>
<li>理解：Vue3.0中一个新的配置项，值为一个函数。</li>
<li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li>
<li>组件中所用到的：数据、方法等等，均要配置在setup中。</li>
<li>setup函数的两种返回值：
<ol>
<li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li>
<li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li>
</ol>
</li>
<li>注意点：
<ol>
<li>尽量不要与Vue2.x配置混用
<ul>
<li>Vue2.x配置（data、methos、computed...）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li>
<li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed...）。</li>
<li>如果有重名, setup优先。</li>
</ul>
</li>
<li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li>
</ol>
</li>
</ol>
<h2 id="2ref函数">2.ref函数</h2>
<ul>
<li>作用: 定义一个响应式的数据</li>
<li>语法: <code>const xxx = ref(initValue)</code>
<ul>
<li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li>
<li>JS中操作数据： <code>xxx.value</code></li>
<li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;{{xxx}}&lt;/div&gt;</code></li>
</ul>
</li>
<li>备注：
<ul>
<li>接收的数据可以是：基本类型、也可以是对象类型。</li>
<li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li>
<li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li>
</ul>
</li>
</ul>
<h2 id="3reactive函数">3.reactive函数</h2>
<ul>
<li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li>
<li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li>
<li>reactive定义的响应式数据是“深层次的”。</li>
<li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li>
</ul>
<h2 id="4vue30中的响应式原理">4.Vue3.0中的响应式原理</h2>
<h3 id="vue2x的响应式">vue2.x的响应式</h3>
<ul>
<li>
<p>实现原理：</p>
<ul>
<li>
<p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>
</li>
<li>
<p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p>
<pre><code class="language-js">Object.defineProperty(data, 'count', {
    get () {}, 
    set () {}
})
</code></pre>
</li>
</ul>
</li>
<li>
<p>存在问题：</p>
<ul>
<li>新增属性、删除属性, 界面不会更新。</li>
<li>直接通过下标修改数组, 界面不会自动更新。</li>
</ul>
</li>
</ul>
<h3 id="vue30的响应式">Vue3.0的响应式</h3>
<ul>
<li>实现原理:
<ul>
<li>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</li>
<li>通过Reflect（反射）:  对源对象的属性进行操作。</li>
<li>MDN文档中描述的Proxy与Reflect：
<ul>
<li>
<p>Proxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</p>
</li>
<li>
<p>Reflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</p>
<pre><code class="language-js">new Proxy(data, {
	// 拦截读取属性值
    get (target, prop) {
    	return Reflect.get(target, prop)
    },
    // 拦截设置属性值或添加新属性
    set (target, prop, value) {
    	return Reflect.set(target, prop, value)
    },
    // 拦截删除属性
    deleteProperty (target, prop) {
    	return Reflect.deleteProperty(target, prop)
    }
})

proxy.name = 'tom'   
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5reactive对比ref">5.reactive对比ref</h2>
<ul>
<li>从定义数据角度对比：
<ul>
<li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li>
<li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li>
<li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li>
</ul>
</li>
<li>从原理角度对比：
<ul>
<li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li>
<li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li>
</ul>
</li>
<li>从使用角度对比：
<ul>
<li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li>
<li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li>
</ul>
</li>
</ul>
<h2 id="6setup的两个注意点">6.setup的两个注意点</h2>
<ul>
<li>
<p>setup执行的时机</p>
<ul>
<li>在beforeCreate之前执行一次，this是undefined。</li>
</ul>
</li>
<li>
<p>setup的参数</p>
<ul>
<li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li>
<li>context：上下文对象
<ul>
<li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li>
<li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li>
<li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7计算属性与监视">7.计算属性与监视</h2>
<h3 id="1computed函数">1.computed函数</h3>
<ul>
<li>
<p>与Vue2.x中computed配置功能一致</p>
</li>
<li>
<p>写法</p>
<pre><code class="language-js">import {computed} from 'vue'

setup(){
    ...
	//计算属性——简写
    let fullName = computed(()=&gt;{
        return person.firstName + '-' + person.lastName
    })
    //计算属性——完整
    let fullName = computed({
        get(){
            return person.firstName + '-' + person.lastName
        },
        set(value){
            const nameArr = value.split('-')
            person.firstName = nameArr[0]
            person.lastName = nameArr[1]
        }
    })
}
</code></pre>
</li>
</ul>
<h3 id="2watch函数">2.watch函数</h3>
<ul>
<li>
<p>与Vue2.x中watch配置功能一致</p>
</li>
<li>
<p>两个小“坑”：</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li>
<li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li>
</ul>
<pre><code class="language-js">//情况一：监视ref定义的响应式数据
watch(sum,(newValue,oldValue)=&gt;{
	console.log('sum变化了',newValue,oldValue)
},{immediate:true})

//情况二：监视多个ref定义的响应式数据
watch([sum,msg],(newValue,oldValue)=&gt;{
	console.log('sum或msg变化了',newValue,oldValue)
}) 

/* 情况三：监视reactive定义的响应式数据
			若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！
			若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 
*/
watch(person,(newValue,oldValue)=&gt;{
	console.log('person变化了',newValue,oldValue)
},{immediate:true,deep:false}) //此处的deep配置不再奏效

//情况四：监视reactive定义的响应式数据中的某个属性
watch(()=&gt;person.job,(newValue,oldValue)=&gt;{
	console.log('person的job变化了',newValue,oldValue)
},{immediate:true,deep:true}) 

//情况五：监视reactive定义的响应式数据中的某些属性
watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;{
	console.log('person的job变化了',newValue,oldValue)
},{immediate:true,deep:true})

//特殊情况
watch(()=&gt;person.job,(newValue,oldValue)=&gt;{
    console.log('person的job变化了',newValue,oldValue)
},{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效
</code></pre>
</li>
</ul>
<h3 id="3watcheffect函数">3.watchEffect函数</h3>
<ul>
<li>
<p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p>
</li>
<li>
<p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p>
</li>
<li>
<p>watchEffect有点像computed：</p>
<ul>
<li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li>
<li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li>
</ul>
<pre><code class="language-js">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。
watchEffect(()=&gt;{
    const x1 = sum.value
    const x2 = person.age
    console.log('watchEffect配置的回调执行了')
})
</code></pre>
</li>
</ul>
<h2 id="8生命周期">8.生命周期</h2>
<h3 id="vue2x的生命周期">vue2.x的生命周期</h3>
<img src="https://cn.vuejs.org/images/lifecycle.png" alt="lifecycle_2" style="zoom:33%;width:1200px" />
<h3 id="vue30的生命周期">vue3.0的生命周期</h3>
<img src="https://v3.cn.vuejs.org/images/lifecycle.svg" alt="lifecycle_2" style="zoom:33%;width:2500px" />
<p>1</p>
<ul>
<li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：
<ul>
<li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li>
<li><code>destroyed</code>改名为 <code>unmounted</code></li>
</ul>
</li>
<li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：
<ul>
<li><code>beforeCreate</code>===&gt;<code>setup()</code></li>
<li><code>created</code>=======&gt;<code>setup()</code></li>
<li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li>
<li><code>mounted</code>=======&gt;<code>onMounted</code></li>
<li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li>
<li><code>updated</code> =======&gt;<code>onUpdated</code></li>
<li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li>
<li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li>
</ul>
</li>
</ul>
<h2 id="9自定义hook函数">9.自定义hook函数</h2>
<ul>
<li>
<p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p>
</li>
<li>
<p>类似于vue2.x中的mixin。</p>
</li>
<li>
<p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p>
</li>
</ul>
<h2 id="10toref">10.toRef</h2>
<ul>
<li>
<p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p>
</li>
<li>
<p>语法：<code>const name = toRef(person,'name')</code></p>
</li>
<li>
<p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p>
</li>
<li>
<p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p>
</li>
</ul>
<h1 id="三-其它-composition-api">三、其它 Composition API</h1>
<h2 id="1shallowreactive-与-shallowref">1.shallowReactive 与 shallowRef</h2>
<ul>
<li>
<p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p>
</li>
<li>
<p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p>
</li>
<li>
<p>什么时候使用?</p>
<ul>
<li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li>
<li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li>
</ul>
</li>
</ul>
<h2 id="2readonly-与-shallowreadonly">2.readonly 与 shallowReadonly</h2>
<ul>
<li>readonly: 让一个响应式数据变为只读的（深只读）。</li>
<li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li>
<li>应用场景: 不希望数据被修改时。</li>
</ul>
<h2 id="3toraw-与-markraw">3.toRaw 与 markRaw</h2>
<ul>
<li>toRaw：
<ul>
<li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>
</ul>
</li>
<li>markRaw：
<ul>
<li>作用：标记一个对象，使其永远不会再成为响应式对象。</li>
<li>应用场景:
<ol>
<li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li>
<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="4customref">4.customRef</h2>
<ul>
<li>
<p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p>
</li>
<li>
<p>实现防抖效果：</p>
<pre><code class="language-js">&lt;template&gt;
	&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;
	&lt;h3&gt;{{keyword}}&lt;/h3&gt;
&lt;/template&gt;

&lt;script&gt;
	import {ref,customRef} from 'vue'
	export default {
		name:'Demo',
		setup(){
			// let keyword = ref('hello') //使用Vue准备好的内置ref
			//自定义一个myRef
			function myRef(value,delay){
				let timer
				//通过customRef去实现自定义
				return customRef((track,trigger)=&gt;{
					return{
						get(){
							track() //告诉Vue这个value值是需要被“追踪”的
							return value
						},
						set(newValue){
							clearTimeout(timer)
							timer = setTimeout(()=&gt;{
								value = newValue
								trigger() //告诉Vue去更新界面
							},delay)
						}
					}
				})
			}
			let keyword = myRef('hello',500) //使用程序员自定义的ref
			return {
				keyword
			}
		}
	}
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h2 id="5provide-与-inject">5.provide 与 inject</h2>
<img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" />
<ul>
<li>
<p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p>
</li>
<li>
<p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>
</li>
<li>
<p>具体写法：</p>
<ol>
<li>
<p>祖组件中：</p>
<pre><code class="language-js">setup(){
	......
    let car = reactive({name:'奔驰',price:'40万'})
    provide('car',car)
    ......
}
</code></pre>
</li>
<li>
<p>后代组件中：</p>
<pre><code class="language-js">setup(props,context){
	......
    const car = inject('car')
    return {car}
	......
}
</code></pre>
</li>
</ol>
</li>
</ul>
<h2 id="6响应式数据的判断">6.响应式数据的判断</h2>
<ul>
<li>isRef: 检查一个值是否为一个 ref 对象</li>
<li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li>
<li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li>
<li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li>
</ul>
<h1 id="四-composition-api-的优势">四、Composition API 的优势</h1>
<h2 id="1options-api-存在的问题">1.Options API 存在的问题</h2>
<p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"><br>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"></p>
<h2 id="2composition-api-的优势">2.Composition API 的优势</h2>
<p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。<br>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"><br>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image" alt="" loading="lazy"></p>
<h1 id="五-新的组件">五、新的组件</h1>
<h2 id="1fragment">1.Fragment</h2>
<ul>
<li>在Vue2中: 组件必须有一个根标签</li>
<li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li>
<li>好处: 减少标签层级, 减小内存占用</li>
</ul>
<h2 id="2teleport">2.Teleport</h2>
<ul>
<li>
<p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p>
<pre><code class="language-vue">&lt;teleport to=&quot;移动位置&quot;&gt;
	&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;
		&lt;div class=&quot;dialog&quot;&gt;
			&lt;h3&gt;我是一个弹窗&lt;/h3&gt;
			&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;
		&lt;/div&gt;
	&lt;/div&gt;
&lt;/teleport&gt;
</code></pre>
</li>
</ul>
<h2 id="3suspense">3.Suspense</h2>
<ul>
<li>
<p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
</li>
<li>
<p>使用步骤：</p>
<ul>
<li>
<p>异步引入组件</p>
<pre><code class="language-js">import {defineAsyncComponent} from 'vue'
const Child = defineAsyncComponent(()=&gt;import('./components/Child.vue'))
</code></pre>
<ul>
<li>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></li>
</ul>
<pre><code class="language-js">&lt;template&gt;
            div&gt;
            class=&quot;app&quot;&gt;
                我是App组件&lt;/h3&gt;
                    e&gt;
                &lt;template v-slot:default&gt;
                    &lt;Child/&gt;
                    mplate&gt;
                &lt;template v-slot:fallback&gt;
                    &lt;h3&gt;加载中.....&lt;/h3&gt;
                &lt;/template&gt;
            &lt;/Suspense&gt;
        &lt;/div&gt;
&lt;/template&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="六-其他">六、其他</h1>
<h2 id="1全局api的转移">1.全局API的转移</h2>
<ul>
<li>Vue 2.x 有许多全局 API 和配置。
<ul>
<li>例如：注册全局组件、注册全局指令等。</li>
</ul>
</li>
</ul>
<pre><code class="language-js">//注册全局组件
Vue.component('MyButton', {
    data: () =&gt; ({
    count: 0
    }),
    template: '&lt;button @click=&quot;count++&quot;&gt;Clicked {{ count }} times.&lt;/button&gt;'
})

//注册全局指令
Vue.directive('focus', {
    inserted: el =&gt; el.focus()
}
</code></pre>
<ul>
<li>
<p>Vue3.0中对这些API做出了调整：</p>
<ul>
<li>
<p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p>
<table>
<thead>
<tr>
<th>2.x 全局 API（<code>Vue</code>）</th>
<th>3.x 实例 API (<code>app</code>)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vue.config.xxxx</td>
<td>app.config.xxxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td><strong style="color:#DD5145">移除</strong></td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<h2 id="2其他改变">2.其他改变</h2>
<ul>
<li>
<p>data选项应始终被声明为一个函数。</p>
</li>
<li>
<p>过度类名的更改：</p>
<ul>
<li>
<p>Vue2.x写法</p>
<pre><code class="language-css">.v-enter,
.v-leave-to {
  opacity: 0;
}
.v-leave,
.v-enter-to {
  opacity: 1;
}
</code></pre>
</li>
<li>
<p>Vue3.x写法</p>
<pre><code class="language-css">.v-enter-from,
.v-leave-to {
  opacity: 0;
}

.v-leave-from,
.v-enter-to {
  opacity: 1;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p>
</li>
<li>
<p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p>
<ul>
<li>
<p>父组件中绑定事件</p>
<pre><code class="language-js">&lt;my-component
  v-on:close=&quot;handleComponentEvent&quot;
  v-on:click=&quot;handleNativeClickEvent&quot;
/&gt;
</code></pre>
</li>
<li>
<p>子组件中声明自定义事件</p>
<pre><code class="language-js">&lt;script&gt;
  export default {
    emits: ['close']
  }
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p>
<blockquote>
<p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p>
</blockquote>
</li>
<li>
<p>......</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue源码(二)-Vue响应式原理模拟]]></title>
        <id>https://capfour.github.io/post/vue-yuan-ma-vue-xiang-ying-shi-yuan-li-mo-ni/</id>
        <link href="https://capfour.github.io/post/vue-yuan-ma-vue-xiang-ying-shi-yuan-li-mo-ni/">
        </link>
        <updated>2021-07-09T02:04:21.000Z</updated>
        <content type="html"><![CDATA[<h3 id="整体分析"><strong>整体分析</strong></h3>
<ul>
<li>Vue基本结构</li>
<li>Vue 实例内容</li>
<li>整体结构<br>
<img src="https://capfour.github.io//post-images/1625796652037.jpg" alt="" loading="lazy"></li>
<li>Vue
<ul>
<li>把data中的成员注入到Vue实例，并且把data中的成员转成getter/setter</li>
</ul>
</li>
<li>Observer
<ul>
<li>能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知Dep</li>
</ul>
</li>
<li>Compiler
<ul>
<li>解析每个元素中的指令/插值表达式，并替换成相应的数据</li>
</ul>
</li>
<li>Dep
<ul>
<li>添加观察者（watcher），当数据变化通知所有的观察者</li>
</ul>
</li>
<li>Watcher
<ul>
<li>数据变化更新视图</li>
</ul>
</li>
</ul>
<h3 id="vue"><strong>Vue</strong></h3>
<ul>
<li>功能
<ul>
<li>负责接受初始化的参数（选项）</li>
<li>负责把data中的属性注入到Vue实例，转换成getter/setter</li>
<li>负责调用observer监听data中所有的属性的变化</li>
<li>负责调用compiler解析指令/插值表达式</li>
</ul>
</li>
<li>结构<br>
<img src="https://capfour.github.io//post-images/1625813961500.jpg" alt="" loading="lazy"></li>
<li>代码<pre><code class="language-js"></code></pre>
</li>
</ul>
<p>class Vue {<br>
constructor (options) {<br>
// 1.保存选项的数据<br>
this.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>s</mi><mo>=</mo><mi>o</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mrow></mrow><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">options = options | | {}
        this.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord">.</span></span></span></span>data = options.data | | {}<br>
const el = options.el<br>
this.<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>l</mi><mo>=</mo><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi><mi>o</mi><mi>f</mi><mi>o</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>e</mi><mi>l</mi><mo>=</mo><mo>=</mo><msup><mo>=</mo><mo mathvariant="normal">′</mo></msup><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><msup><mi>g</mi><mo mathvariant="normal">′</mo></msup><mo>?</mo><mi>d</mi><mi>o</mi><mi>c</mi><mi>u</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mi>S</mi><mi>e</mi><mi>l</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>(</mo><mi>e</mi><mi>l</mi><mo>)</mo><mo>:</mo><mi>e</mi><mi>l</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">/</mi><mn>2.</mn><mi mathvariant="normal">负</mi><mi mathvariant="normal">责</mi><mi mathvariant="normal">把</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">注</mi><mi mathvariant="normal">入</mi><mi mathvariant="normal">到</mi><mi>V</mi><mi>u</mi><mi>e</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">例</mi><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><msub><mi mathvariant="normal">.</mi><mi>p</mi></msub><mi>r</mi><mi>o</mi><mi>x</mi><mi>y</mi><mi>D</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo>(</mo><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">el = typeof options.el === &#x27;string&#x27; ? document.querySelector(el): el 
        //2. 负责把data 注入到 Vue实例
        this._proxyData(this.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">?</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">/</span><span class="mord">/</span><span class="mord">2</span><span class="mord">.</span><span class="mord cjk_fallback">负</span><span class="mord cjk_fallback">责</span><span class="mord cjk_fallback">把</span><span class="mord mathdefault">d</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord cjk_fallback">注</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">到</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">例</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord">.</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord">.</span></span></span></span>data)<br>
}</p>
<pre><code>_proxyData (data){
    //遍历data 的所有属性
    object.defineproperty(this, key, {
        get(){
            return data[key]
        },
        set(newValue){
            if(data[key] === newValue) return;
            data[key] = newValue
        }
    })
}
</code></pre>
<p>}</p>
<pre><code>### **Observer**
- 功能
    - 负责把data选项中的属性转换成响应式数据
    - data中的某个属性也是对象，把该属性转换成响应式数据
    - 数据变化发送通知
- 结构
![](https://capfour.github.io//post-images/1625814958011.jpg)
- 代码
```js
//负责数据劫持,把$data中的成员转换成 getter/setter
class Observer {
    constructor (data) {
        this.walk(data)
    }
    //1. 判断数据是否是对象，如果不是对象就return
    //2.如果是对象，就遍历对象的所有属性，设置为getter/setter
    walk（data）{
        if(!data || typeof data !== 'object') return;
        object.keys(data).forEach(key =&gt; {
            this.defineReactive(data, key, data[key])
        })
    }
    //定义响应式成员
    defineReactive（data, key, val）{
        const _this = this
        //如果 val 是对象，继续设置它下面的成员为响应式数据
        this.walk(val)
        object.defineProperty(data, key, {
            configurable: true,
            enumerable: true,
            get () {
                return val
            },
            set (newValue) {
                if (newValue === val) return;
                //如果newValue是对象，设置newValue的成员为响应式
                this.walk(newValue)
                val = newValue
            }
        })
    }
}
</code></pre>
<h3 id="compiler"><strong>Compiler</strong></h3>
<ul>
<li>功能
<ul>
<li>负责编译模板，解析指令/插值表达式</li>
<li>负责页面的首次渲染</li>
<li>当数据变化后重新渲染视图</li>
</ul>
</li>
<li>结构<br>
<img src="https://capfour.github.io//post-images/1625820312200.jpg" alt="" loading="lazy"></li>
</ul>
<h4 id="compile"><strong>compile</strong></h4>
<pre><code class="language-js">//负责解析指令/插值表达式
class Compiler {
    constructor (vm) {
        this.vm = vm
        this.el = vm.$el
        //编译模板
        this.compile(this.el)
    }
    //编译模板
    //处理文本节点和元素节点
    compile（）{
        const nodes = el.childNodes
        Array.from(nodes).forEach(node =&gt; {
            //判断是文本节点还是元素节点
            if(this.isTextNode){
                this.compileText(node)
            }else if (this.isElementNode(node)){
                this.compileElement(node)
            }
            if(node.childNodes &amp;&amp; node.childNodes.length) {
                this.compile(node)
            }
        })
    }

    //判断是否是文本节点
    isTextNode ( node ) {
        return node.nodeType === 3
    }
    //判断是否是元素节点
    isElementNode (node ) {
        return node.nodeType === 1
    }
    //判断是否是以 v- 开头的指令
    isDirective (attrName){
        return attrName.startsWith('v-')
    }
    //编译文本节点
    compileText（node）{

    }
    //编译元素节点
    compileElement（node）{

    }
}
</code></pre>
<h4 id="compiletext"><strong>compileText()</strong></h4>
<ul>
<li>负责编译插值表达式</li>
</ul>
<pre><code class="language-js">    //编译文本节点
    compileText (node) {
        const reg = /\{\{(.+)\}\}/
        //获取文本节点内容
        const value = node.textContent
        if(reg.test(value)) {
            //插值表达式中的值就是我们要的属性名称
            const key = RegExp.$1.trim()
            //把插值表达式替换成具体的值
            node.textContent = value.replace(reg, this.vm[key])
        }
    }
</code></pre>
<h4 id="compileelement"><strong>compileElement()</strong></h4>
<ul>
<li>负责编译元素的指令</li>
<li>处理v-text 的首次渲染</li>
<li>处理v-model的首次渲染</li>
</ul>
<pre><code class="language-js">//编译属性节点
compileElement (node) {
    //遍历元素节点中的所有属性，找到指令
    Array.from(node.attrbutes).forEach(attr =&gt; {
        let attrName = attr.name
        //判断当前的属性名称是否是指令
        if(this.isDirective(attrName)) {
            //attrName 的形式 v-text v-model
            //截取属性的名称，获取 text model
            atttrName = attrName.substr(2)
            //获取属性的名称，属性的名称就是我们数据对象那个的属性 v-text = &quot;name&quot;,获取的是name
            const key = attr.value
            //处理不同的指令
            this.update(node, key, attrName)
        }
    })
}

//负责更新DOM
//创建Watcher
update(node, key, dir){
    // node 节点，key 数据的属性名称， dir 指令的后半部分
    const updaterFn = this[dir + 'updater']
    updaterFn &amp;&amp; updaterFn(node, this.vm [key])
}

//v-text 指令的更新办法
textUpdater(node, value) {
    node.textContent = value
}

//v-model 指令的更新方法
modelUpdater (node, value){
    node.value = value
}
</code></pre>
<h4 id="depdependency"><strong>Dep(Dependency)</strong></h4>
<figure data-type="image" tabindex="1"><img src="https://capfour.github.io//post-images/1626329292374.png" alt="" loading="lazy"></figure>
<ul>
<li>功能
<ul>
<li>收集依赖，添加观察者（watcher）</li>
<li>通知所有观察者</li>
</ul>
</li>
<li>结构<br>
<img src="https://capfour.github.io//post-images/1626329374340.png" alt="" loading="lazy"></li>
<li>代码</li>
</ul>
<pre><code class="language-js">    class Dep {
        constructor () {
            //存储所有的观察者
            this.subs = []
        }
        //添加观察者
        addsub (sub){
            if(sub &amp;&amp; sub.update){
                this.subs.push(sub)
            }
        }
        //通知所有观察者
        notify (){
            this.subs.forEach(sub=&gt;{
                sub.update()
            })
        }
    }
</code></pre>
<ul>
<li>在compiler.js中收集依赖，发送通知</li>
</ul>
<pre><code class="language-js">//在defineReactive中
//创建dep对象收集依赖
const dep = new Dep()

//getter中
//get的过程中收集依赖
Dep.tatget &amp;&amp; dep.addSub(Dep.target)

//setter中
//当数据变化之后，发送通知
dep.notify()
</code></pre>
<h4 id="watcher"><strong>Watcher</strong></h4>
<figure data-type="image" tabindex="2"><img src="https://capfour.github.io//post-images/1626933769169.png" alt="" loading="lazy"></figure>
<ul>
<li>功能
<ul>
<li>当数据变化触发依赖，dep通知所有的Watcher实例更新视图</li>
<li>自身实例化的时候往dep对象中添加自己</li>
</ul>
</li>
<li>结构<br>
<img src="https://capfour.github.io//post-images/1626933919252.png" alt="" loading="lazy"></li>
<li>代码</li>
</ul>
<pre><code class="language-js">class Watcher {
    constructor (vm,key,cb){
        this.vm = vm
        //data中的属性名称
        this.key = key
        //当数据变化的时候，调用cb更新视图
        this.cb = cb
        //在Dep的静态属性上记录当前watcher对象，当访问数据的时候把watcher添加到dep的subs中
        Dep.target = this
        //触发一次getter，让dep为当前key记录watcher
        this.oldvalue = null
        //清空target
        Dep.target = null
    }

    update(){
        const newvalue = this.vm[this.key]
        if(this.oldvalue === newvalue){
            return
        }
        this.cb(newvalue)
    }
}
</code></pre>
<ul>
<li>在compiler.js中为每一个指令/插值表达式创建watcher对象，监视数据的变化</li>
</ul>
<pre><code class="language-js">//因为在textUpdater中要使用this
updaterFn &amp;&amp; updaterFn.call(this,node,this.vm[key],key)

//v-text指令的更新方法
textUpdater (node,value,key){
    node.textContent = value
    //每一个指令中创建一个 watcher，观察数据的变化
    new Watcher(this.vm,key,value =&gt; {
        node.textContent = value
    })
}
</code></pre>
<h4 id="视图变化更新数据"><strong>视图变化更新数据</strong></h4>
<pre><code class="language-js">//v-model 指令的更新方法
modelUpdater (node,value,key) {
    node.value = value
    //每一个指令中创建一个watcher，观察数据的变化
    new Watcher(this.vm,key,value =&gt; {
        node.value = value
    })
    //监听视图的变化
    node.addEventLinstener('input', ()=&gt;{
        this.vm[key] = node.value
    })
}
</code></pre>
<h4 id="总结"><strong>总结</strong></h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue源码(一)-数据响应式原理]]></title>
        <id>https://capfour.github.io/post/vue-yuan-ma-shu-ju-xiang-ying-shi-yuan-li/</id>
        <link href="https://capfour.github.io/post/vue-yuan-ma-shu-ju-xiang-ying-shi-yuan-li/">
        </link>
        <updated>2021-07-07T06:46:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="学习目的"><strong>学习目的</strong></h3>
<ul>
<li>模拟一个最小版本的vue</li>
<li>实际项目中出问题的原理层面的解决
<ul>
<li>给vue实例新增一个成员是否是响应式的？</li>
<li>给属性重新赋值称对象，是否是响应式的?</li>
</ul>
</li>
</ul>
<h3 id="准备工作"><strong>准备工作</strong></h3>
<ul>
<li>数据驱动</li>
<li>响应式核心原理</li>
<li>发布订阅模式和观察者模式</li>
</ul>
<h3 id="数据驱动"><strong>数据驱动</strong></h3>
<ul>
<li>数据响应式
<ul>
<li>数据模型仅仅是普通的javaScript对象，而当我们修改数据时，视图会进行更新，避免了繁琐的DOM操作 ，提高开发效率</li>
</ul>
</li>
<li>双向绑定
<ul>
<li>数据改变，视图改变；试图改变，数据也随之改变</li>
<li>我们可以使用 v-model 在表单元素上创建双向数据绑定</li>
</ul>
</li>
<li>数据驱动是Vue最独特的特性之一
<ul>
<li>开发过程中仅需要关注数据本身，不需要关心数据是如何渲染到视图</li>
</ul>
</li>
</ul>
<h3 id="数据响应式的核心原理"><strong>数据响应式的核心原理</strong></h3>
<h3 id="vue-2x">Vue 2.x</h3>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN - Object.defineProperty</a></li>
<li>浏览器兼容IE8以上（不兼容IE8）</li>
</ul>
<pre><code class="language-js">// 模拟 Vue 中的 data 选项
let data = {
    msg: 'hello'
}

// 模拟  Vue 的实例
let vm = { }

//数据劫持：当访问或者设置vm中的成员的时候，做一些干预操作
object.defineProperty(vm, 'msg', {
    // 可枚举（可遍历）
    enumerable：true，
    // 可配置（可以使用delete删除，可以通过defineProperty重新定义）
    configurable: true,
    // 当获取值的时候执行
    get(){
        ocnsole.log('get',data.msg)
    },
    // 当设置值的时候执行
    set(newValue){
        console.log('set',newValue)
        if(newValue === data.msg) return;
        data.msg = newValue
        // 数据更改，更新 DOM 的值
        document.querySelector('#app').textContent = data.msg
    }
})

//测试
vm.msg = 'Hello world'
console.log(vm.msg)
</code></pre>
<h3 id="vue-3x">Vue 3.x</h3>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">MDN - Proxy</a></li>
<li>直接监听对象，而非属性</li>
<li>ES6中新增，IE不支持，性能由浏览器优化</li>
</ul>
<pre><code class="language-js">// 模拟 Vue 中的data选项
let data = {
    msg: 'hello',
    count: 0
}
// 模拟 Vue 实例
let vm = new Proxy( data, {
    //当访问 vm 成员会执行
    get (target, key) {
        console.log('get, key: ', key, target[key])
        return target[key]
    },
    //当设置 vm 的成员会执行
    set (target, key, newValue){
        console.log('set,key: ', key, newValue)
        if(target[key] === newValue) return;
        target[key] = newValue
        document.querySelector('#app').textContent = target[key]
    }
})
//测试
vm.msg = 'hello World'
console.log(vm.msg)
</code></pre>
<h3 id="发布订阅者模式和观察者模式"><strong>发布订阅者模式和观察者模式</strong></h3>
<h4 id="发布订阅模式"><strong>发布/订阅模式</strong></h4>
<ul>
<li>
<p>发布/订阅模式</p>
<ul>
<li>订阅者</li>
<li>发布者</li>
<li>信号中心</li>
</ul>
<p>我们假定，存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行，<strong>这就叫做“发布/订阅模式（publish-subscribe pattern）”</strong>。</p>
</li>
<li>
<p>vue 兄弟组件通信</p>
</li>
</ul>
<pre><code class="language-js">// eventBus.js 
// 事件中心 
let eventHub = new Vue() 

// ComponentA.vue 
// 发布者 

addTodo: function () {
    // 发布消息(事件) 
    eventHub.$emit('add-todo', { text: this.newTodoText })
    this.newTodoText = ' ' 
}

// ComponentB.vue 
// 订阅者 

created: function () {
    // 订阅消息(事件)
    eventHub.$on('add-todo', this.addTodo) 
}
</code></pre>
<ul>
<li>自定义事件实现</li>
</ul>
<pre><code class="language-js">class EventEmiter {
    constructor() {
        this.events = {}
    }
    emit(event, ...args) {
        this.events[event].forEach(fn =&gt; {
            fn.apply(this, args)
        })
    }
    on(event, fn) {
        if (this.events[event]) {
            this.events[event].push(fn)
        } else {
            this.events[event] = [fn]
        }
    }
    remove(event) {
        delete this.events[event]
    }
}

const eventHub = new EventEmiter()

eventHub.on('test', data =&gt; {
    console.log(data)
})

eventHub.emit('test', 1)
</code></pre>
<h4 id="观察者模式"><strong>观察者模式</strong></h4>
<ul>
<li>观察者（订阅者）-- Watcher
<ul>
<li>update(): 当事件发生时，具体要做的事</li>
</ul>
</li>
<li>目标（发布者） -- Dep
<ul>
<li>subs 数组：存储所有的观察者</li>
<li>addSub() ：添加观察者</li>
<li>notufy() : 当事件发生，调用所有的观察者的update() 方法</li>
</ul>
</li>
<li>没有事件中心</li>
</ul>
<pre><code class="language-js">// 目标（发布者）
// Dependency
calss Dep {
    constructor(){
        // 存储所有的观察者
        this.subs = []
    }
    // 添加观察者
    addSub(sub){
        if(sub&amp;&amp;sub.update) {
            this.subs.push(sub)
        }
    }
    // 通知所有的观察者
    notify(){
        this.subs.forEach(sub=&gt;{
            sub.update()
        })
    }
}
// 观察者（订阅者）
class watcher {
    update(){
        console.log('update')
    }
}
// 测试
let dep = new Dep()
let watcher = new Watcher()
dep.addSub(watcher)
dep.notify()
</code></pre>
<h4 id="总结"><strong>总结</strong></h4>
<ul>
<li><strong>观察者模式</strong>是由具体目标调度，比如当事件触发，Dep就会去调用观察者的方法，所以观察者模式的订阅者与发布者之间是存在依赖的。</li>
<li><strong>发布/订阅模式</strong>由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://capfour.github.io//post-images/1625651644043.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[手动实现call(), apply(), bind()]]></title>
        <id>https://capfour.github.io/post/shou-dong-shi-xian-call-apply-bind/</id>
        <link href="https://capfour.github.io/post/shou-dong-shi-xian-call-apply-bind/">
        </link>
        <updated>2021-07-07T02:33:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-call-apply-bind-其作用都是改变函数运行时this的指向">一、call、apply、bind 其作用都是改变函数运行时this的指向</h2>
<pre><code>1, call 的参数是直接放进去的，用逗号分隔   
2, apply 的所有参数都必须放在一个数组里面传进去  
3, bind 除了返回是函数以外，它的参数和 call 一样；与上面两者不同的是bind不会立即执行函数，而call和apply会执行函数
</code></pre>
<h2 id="二-手动实现三个函数">二、手动实现三个函数</h2>
<h3 id="1-tips">1、<strong>tips</strong></h3>
<pre><code>1、实际上，每个 JavaScript 函数都是一个 Function 对象
    console.log((function(){}).constructor === Function)
2、自定义一个全局方法可以在Function.prototype上定义一个方法
</code></pre>
<h3 id="2-call">2、<strong>call</strong></h3>
<pre><code class="language-js">Function.prototype.myCall = function (context) {
    //调用对象校验
    if (typeof this !== 'function') {
        console.log(&quot;type error&quot;);
    }
    //this指向默认window
    context = context || window

    //获取参数
    let args = [...arguments].slice(1)

    context.fn = this
    const result = context.fn(...args)
    delete context.fn
    return result
}
</code></pre>
<h3 id="3-apply">3、 <strong>apply</strong></h3>
<pre><code class="language-js">Function.prototype.myApply = function (context) {
        //调用对象校验
    if(typeof this !== 'function') {
        throw new TypeError('error')
    }
    let result = null
    //this指向默认window
    context = context || window
    // 把当前调用的函数赋值给传入对象的
    // context.fn 可以理解为： context.prototype.
    context.fn = this
    if (arguments[1]) {
        result = context.fn([...arguments[1]]) // 调用赋值的函数
    }
    delete context.fn
    return result
}
</code></pre>
<h3 id="4-bind">4、<strong>bind</strong></h3>
<pre><code class="language-js">Function.prototype.myBind = function(context) {
    if (typeof this !== 'function') {
        throw new TypeError('error')
    }
    // 获取参数
    let args = [...arguments].slice(1) // 第一个是对象
    context.fn = this // 调用对象
    return function Fn() {
            return fn.apply(this instanceof Fn ? this : context, args.concat(...arguments)) }
}
</code></pre>
<h3 id="三-总结">三, <strong>总结</strong></h3>
<pre><code>bind和call与apply的区别是不会立即调用函数，常用于改变回调函数的参数，bind的参数传递方式和call一样
</code></pre>
]]></content>
    </entry>
</feed>