<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://capfour.github.io/</id>
    <title>FEfour的笔记</title>
    <updated>2021-07-22T03:43:10.332Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://capfour.github.io/"/>
    <link rel="self" href="https://capfour.github.io/atom.xml"/>
    <subtitle>FEfour的笔记</subtitle>
    <logo>https://capfour.github.io/images/avatar.png</logo>
    <icon>https://capfour.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, FEfour的笔记</rights>
    <entry>
        <title type="html"><![CDATA[Vue源码(二)-Vue响应式原理模拟]]></title>
        <id>https://capfour.github.io/post/vue-yuan-ma-vue-xiang-ying-shi-yuan-li-mo-ni/</id>
        <link href="https://capfour.github.io/post/vue-yuan-ma-vue-xiang-ying-shi-yuan-li-mo-ni/">
        </link>
        <updated>2021-07-09T02:04:21.000Z</updated>
        <content type="html"><![CDATA[<h3 id="整体分析"><strong>整体分析</strong></h3>
<ul>
<li>Vue基本结构</li>
<li>Vue 实例内容</li>
<li>整体结构<br>
<img src="https://capfour.github.io//post-images/1625796652037.jpg" alt="" loading="lazy"></li>
<li>Vue
<ul>
<li>把data中的成员注入到Vue实例，并且把data中的成员转成getter/setter</li>
</ul>
</li>
<li>Observer
<ul>
<li>能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知Dep</li>
</ul>
</li>
<li>Compiler
<ul>
<li>解析每个元素中的指令/插值表达式，并替换成相应的数据</li>
</ul>
</li>
<li>Dep
<ul>
<li>添加观察者（watcher），当数据变化通知所有的观察者</li>
</ul>
</li>
<li>Watcher
<ul>
<li>数据变化更新视图</li>
</ul>
</li>
</ul>
<h3 id="vue"><strong>Vue</strong></h3>
<ul>
<li>
<p>功能</p>
<ul>
<li>负责接受初始化的参数（选项）</li>
<li>负责把data中的属性注入到Vue实例，转换成getter/setter</li>
<li>负责调用observer监听data中所有的属性的变化</li>
<li>负责调用compiler解析指令/插值表达式</li>
</ul>
</li>
<li>
<p>结构<br>
<img src="https://capfour.github.io//post-images/1625813961500.jpg" alt="" loading="lazy"></p>
</li>
<li>
<p>代码</p>
<pre><code>  class Vue {
      constructor (options) {
          // 1.保存选项的数据
          this.$options = options | | {}
          this.$data = options.data | | {}
          const el = options.el
          this.$el = typeof options.el === 'string' ? document.querySelector(el): el 
          //2. 负责把data 注入到 Vue实例
          this._proxyData(this.$data)
      }

      _proxyData (data){
          //遍历data 的所有属性
          object.defineproperty(this, key, {
              get(){
                  return data[key]
              },
              set(newValue){
                  if(data[key] === newValue) return;
                  data[key] = newValue
              }
          })
      }
  }
</code></pre>
</li>
</ul>
<h3 id="observer"><strong>Observer</strong></h3>
<ul>
<li>
<p>功能</p>
<ul>
<li>负责把data选项中的属性转换成响应式数据</li>
<li>data中的某个属性也是对象，把该属性转换成响应式数据</li>
<li>数据变化发送通知</li>
</ul>
</li>
<li>
<p>结构<br>
<img src="https://capfour.github.io//post-images/1625814958011.jpg" alt="" loading="lazy"></p>
</li>
<li>
<p>代码</p>
<pre><code>  //负责数据劫持,把$data中的成员转换成 getter/setter
  class Observer {
      constructor (data) {
          this.walk(data)
      }
      //1. 判断数据是否是对象，如果不是对象就return
      //2.如果是对象，就遍历对象的所有属性，设置为getter/setter
      walk（data）{
          if(!data || typeof data !== 'object') return;
          object.keys(data).forEach(key =&gt; {
              this.defineReactive(data, key, data[key])
          })
      }
      //定义响应式成员
      defineReactive（data, key, val）{
          const _this = this
          //如果 val 是对象，继续设置它下面的成员为响应式数据
          this.walk(val)
          object.defineProperty(data, key, {
              configurable: true,
              enumerable: true,
              get () {
                  return val
              },
              set (newValue) {
                  if (newValue === val) return;
                  //如果newValue是对象，设置newValue的成员为响应式
                  this.walk(newValue)
                  val = newValue
              }
          })
      }
  }
</code></pre>
</li>
</ul>
<h3 id="compiler"><strong>Compiler</strong></h3>
<ul>
<li>功能
<ul>
<li>负责编译模板，解析指令/插值表达式</li>
<li>负责页面的首次渲染</li>
<li>当数据变化后重新渲染视图</li>
</ul>
</li>
<li>结构<br>
<img src="https://capfour.github.io//post-images/1625820312200.jpg" alt="" loading="lazy"></li>
</ul>
<h4 id="compile"><strong>compile</strong></h4>
<pre><code>    //负责解析指令/插值表达式
    class Compiler {
        constructor (vm) {
            this.vm = vm
            this.el = vm.$el
            //编译模板
            this.compile(this.el)
        }
        //编译模板
        //处理文本节点和元素节点
        compile（）{
            const nodes = el.childNodes
            Array.from(nodes).forEach(node =&gt; {
                //判断是文本节点还是元素节点
                if(this.isTextNode){
                    this.compileText(node)
                }else if (this.isElementNode(node)){
                    this.compileElement(node)
                }
                if(node.childNodes &amp;&amp; node.childNodes.length) {
                    this.compile(node)
                }
            })
        }

        //判断是否是文本节点
        isTextNode ( node ) {
            return node.nodeType === 3
        }
        //判断是否是元素节点
        isElementNode (node ) {
            return node.nodeType === 1
        }
        //判断是否是以 v- 开头的指令
        isDirective (attrName){
            return attrName.startsWith('v-')
        }
        //编译文本节点
        compileText（node）{

        }
        //编译元素节点
        compileElement（node）{

        }
    }
</code></pre>
<h4 id="compiletext"><strong>compileText()</strong></h4>
<ul>
<li>
<p>负责编译插值表达式</p>
<pre><code>  //编译文本节点
  compileText (node) {
      const reg = /\{\{(.+)\}\}/
      //获取文本节点内容
      const value = node.textContent
      if(reg.test(value)) {
          //插值表达式中的值就是我们要的属性名称
          const key = RegExp.$1.trim()
          //把插值表达式替换成具体的值
          node.textContent = value.replace(reg, this.vm[key])
      }
  }
</code></pre>
</li>
</ul>
<h4 id="compileelement"><strong>compileElement()</strong></h4>
<ul>
<li>
<p>负责编译元素的指令</p>
</li>
<li>
<p>处理v-text 的首次渲染</p>
</li>
<li>
<p>处理v-model的首次渲染</p>
<pre><code>  //编译属性节点
  compileElement (node) {
      //遍历元素节点中的所有属性，找到指令
      Array.from(node.attrbutes).forEach(attr =&gt; {
          let attrName = attr.name
          //判断当前的属性名称是否是指令
          if(this.isDirective(attrName)) {
              //attrName 的形式 v-text v-model
              //截取属性的名称，获取 text model
              atttrName = attrName.substr(2)
              //获取属性的名称，属性的名称就是我们数据对象那个的属性 v-text = &quot;name&quot;,获取的是name
              const key = attr.value
              //处理不同的指令
              this.update(node, key, attrName)
          }
      })
  }

  //负责更新DOM
  //创建Watcher
  update(node, key, dir){
      // node 节点，key 数据的属性名称， dir 指令的后半部分
      const updaterFn = this[dir + 'updater']
      updaterFn &amp;&amp; updaterFn(node, this.vm [key])
  }

  //v-text 指令的更新办法
  textUpdater(node, value) {
      node.textContent = value
  }

  //v-model 指令的更新方法
  modelUpdater (node, value){
      node.value = value
  }
</code></pre>
</li>
</ul>
<h4 id="depdependency"><strong>Dep(Dependency)</strong></h4>
<figure data-type="image" tabindex="1"><img src="https://capfour.github.io//post-images/1626329292374.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>功能</p>
<ul>
<li>收集依赖，添加观察者（watcher）</li>
<li>通知所有观察者</li>
</ul>
</li>
<li>
<p>结构<br>
<img src="https://capfour.github.io//post-images/1626329374340.png" alt="" loading="lazy"></p>
</li>
<li>
<p>代码</p>
<pre><code>  class Dep {
      constructor () {
          //存储所有的观察者
          this.subs = []
      }
      //添加观察者
      addsub (sub){
          if(sub &amp;&amp; sub.update){
              this.subs.push(sub)
          }
      }
      //通知所有观察者
      notify (){
          this.subs.forEach(sub=&gt;{
              sub.update()
          })
      }
  }
</code></pre>
</li>
<li>
<p>在compiler.js中收集依赖，发送通知</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue源码(一)-数据响应式原理]]></title>
        <id>https://capfour.github.io/post/vue-yuan-ma-shu-ju-xiang-ying-shi-yuan-li/</id>
        <link href="https://capfour.github.io/post/vue-yuan-ma-shu-ju-xiang-ying-shi-yuan-li/">
        </link>
        <updated>2021-07-07T06:46:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="学习目的"><strong>学习目的</strong></h3>
<ul>
<li>模拟一个最小版本的vue</li>
<li>实际项目中出问题的原理层面的解决
<ul>
<li>给vue实例新增一个成员是否是响应式的？</li>
<li>给属性重新赋值称对象，是否是响应式的?</li>
</ul>
</li>
</ul>
<h3 id="准备工作"><strong>准备工作</strong></h3>
<ul>
<li>数据驱动</li>
<li>响应式核心原理</li>
<li>发布订阅模式和观察者模式</li>
</ul>
<h3 id="数据驱动"><strong>数据驱动</strong></h3>
<ul>
<li>数据响应式
<ul>
<li>数据模型仅仅是普通的javaScript对象，而当我们修改数据时，视图会进行更新，避免了繁琐的DOM操作 ，提高开发效率</li>
</ul>
</li>
<li>双向绑定
<ul>
<li>数据改变，视图改变；试图改变，数据也随之改变</li>
<li>我们可以使用 v-model 在表单元素上创建双向数据绑定</li>
</ul>
</li>
<li>数据驱动是Vue最独特的特性之一
<ul>
<li>开发过程中仅需要关注数据本身，不需要关心数据是如何渲染到视图</li>
</ul>
</li>
</ul>
<h3 id="数据响应式的核心原理"><strong>数据响应式的核心原理</strong></h3>
<h3 id="vue-2x">Vue 2.x</h3>
<ul>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN - Object.defineProperty</a></p>
</li>
<li>
<p>浏览器兼容IE8以上（不兼容IE8）</p>
<pre><code>  // 模拟 Vue 中的 data 选项
  let data = {
      msg: 'hello'
  }

  // 模拟  Vue 的实例
  let vm = { }

  //数据劫持：当访问或者设置vm中的成员的时候，做一些干预操作
  object.defineProperty(vm, 'msg', {
      // 可枚举（可遍历）
      enumerable：true，
      // 可配置（可以使用delete删除，可以通过defineProperty重新定义）
      configurable: true,
      // 当获取值的时候执行
      get(){
          ocnsole.log('get',data.msg)
      },
      // 当设置值的时候执行
      set(newValue){
          console.log('set',newValue)
          if(newValue === data.msg) return;
          data.msg = newValue
          // 数据更改，更新 DOM 的值
          document.querySelector('#app').textContent = data.msg
      }
  })

  //测试
  vm.msg = 'Hello world'
  console.log(vm.msg)
</code></pre>
</li>
</ul>
<h3 id="vue-3x">Vue 3.x</h3>
<ul>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">MDN - Proxy</a></p>
</li>
<li>
<p>直接监听对象，而非属性</p>
</li>
<li>
<p>ES6中新增，IE不支持，性能由浏览器优化</p>
<pre><code> // 模拟 Vue 中的data选项
 let data = {
     msg: 'hello',
     count: 0
 }
 // 模拟 Vue 实例
 let vm = new Proxy( data, {
     //当访问 vm 成员会执行
     get (target, key) {
         console.log('get, key: ', key, target[key])
         return target[key]
     },
     //当设置 vm 的成员会执行
     set (target, key, newValue){
         console.log('set,key: ', key, newValue)
         if(target[key] === newValue) return;
         target[key] = newValue
         document.querySelector('#app').textContent = target[key]
     }
 })
 //测试
 vm.msg = 'hello World'
 console.log(vm.msg)
</code></pre>
</li>
</ul>
<h3 id="发布订阅者模式和观察者模式"><strong>发布订阅者模式和观察者模式</strong></h3>
<h4 id="发布订阅模式"><strong>发布/订阅模式</strong></h4>
<ul>
<li>
<p>发布/订阅模式</p>
<ul>
<li>订阅者</li>
<li>发布者</li>
<li>信号中心</li>
</ul>
<p>我们假定，存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行，<strong>这就叫做“发布/订阅模式（publish-subscribe pattern）”</strong>。</p>
</li>
<li>
<p>vue 兄弟组件通信</p>
<pre><code>  // eventBus.js 
  // 事件中心 
  let eventHub = new Vue() 

  // ComponentA.vue 
  // 发布者 

  addTodo: function () {
      // 发布消息(事件) 
      eventHub.$emit('add-todo', { text: this.newTodoText })
      this.newTodoText = ' ' 
  }

  // ComponentB.vue 
  // 订阅者 

  created: function () {
      // 订阅消息(事件)
      eventHub.$on('add-todo', this.addTodo) 
  }
</code></pre>
</li>
<li>
<p>自定义事件实现</p>
<pre><code>  class EventEmiter {
      constructor() {
          this.events = {}
      }
      emit(event, ...args) {
          this.events[event].forEach(fn =&gt; {
              fn.apply(this, args)
          })
      }
      on(event, fn) {
          if (this.events[event]) {
              this.events[event].push(fn)
          } else {
              this.events[event] = [fn]
          }
      }
      remove(event) {
          delete this.events[event]
      }
  }

  const eventHub = new EventEmiter()

  eventHub.on('test', data =&gt; {
      console.log(data)
  })

  eventHub.emit('test', 1)
</code></pre>
</li>
</ul>
<h4 id="观察者模式"><strong>观察者模式</strong></h4>
<ul>
<li>
<p>观察者（订阅者）-- Watcher</p>
<ul>
<li>update(): 当事件发生时，具体要做的事</li>
</ul>
</li>
<li>
<p>目标（发布者） -- Dep</p>
<ul>
<li>subs 数组：存储所有的观察者</li>
<li>addSub() ：添加观察者</li>
<li>notufy() : 当事件发生，调用所有的观察者的update() 方法</li>
</ul>
</li>
<li>
<p>没有事件中心</p>
<pre><code>  // 目标（发布者）
  // Dependency
  calss Dep {
      constructor(){
          // 存储所有的观察者
          this.subs = []
      }
      // 添加观察者
      addSub(sub){
          if(sub&amp;&amp;sub.update) {
              this.subs.push(sub)
          }
      }
      // 通知所有的观察者
      notify(){
          this.subs.forEach(sub=&gt;{
              sub.update()
          })
      }
  }
  // 观察者（订阅者）
  class watcher {
      update(){
          console.log('update')
      }
  }
  // 测试
  let dep = new Dep()
  let watcher = new Watcher()
  dep.addSub(watcher)
  dep.notify()
</code></pre>
</li>
</ul>
<h4 id="总结"><strong>总结</strong></h4>
<ul>
<li><strong>观察者模式</strong>是由具体目标调度，比如当事件触发，Dep就会去调用观察者的方法，所以观察者模式的订阅者与发布者之间是存在依赖的。</li>
<li><strong>发布/订阅模式</strong>由统一调度中心调用，因此发布者和订阅者不需要知道对方的存在。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://capfour.github.io//post-images/1625651644043.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[手动实现call(), apply(), bind()]]></title>
        <id>https://capfour.github.io/post/shou-dong-shi-xian-call-apply-bind/</id>
        <link href="https://capfour.github.io/post/shou-dong-shi-xian-call-apply-bind/">
        </link>
        <updated>2021-07-07T02:33:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-call-apply-bind-其作用都是改变函数运行时this的指向">一、call、apply、bind 其作用都是改变函数运行时this的指向</h2>
<pre><code>1, call 的参数是直接放进去的，用逗号分隔   
2, apply 的所有参数都必须放在一个数组里面传进去  
3, bind 除了返回是函数以外，它的参数和 call 一样；与上面两者不同的是bind不会立即执行函数，而call和apply会执行函数
</code></pre>
<h2 id="二-手动实现三个函数">二、手动实现三个函数</h2>
<h3 id="1-tips">1、<strong>tips</strong></h3>
<pre><code>1、实际上，每个 JavaScript 函数都是一个 Function 对象
    console.log((function(){}).constructor === Function)
2、自定义一个全局方法可以在Function.prototype上定义一个方法
</code></pre>
<h3 id="2-call">2、<strong>call</strong></h3>
<pre><code>Function.prototype.myCall = function (context) {
    //调用对象校验
    if (typeof this !== 'function') {
        console.log(&quot;type error&quot;);
    }
    //this指向默认window
    context = context || window

    //获取参数
    let args = [...arguments].slice(1)

    context.fn = this
    const result = context.fn(...args)
    delete context.fn
    return result
}
</code></pre>
<h3 id="3-apply">3、 <strong>apply</strong></h3>
<pre><code>Function.prototype.myApply = function (context) {
     //调用对象校验
    if(typeof this !== 'function') {
        throw new TypeError('error')
    }
    let result = null
   //this指向默认window
    context = context || window
    // 把当前调用的函数赋值给传入对象的
    // context.fn 可以理解为： context.prototype.
    context.fn = this
    if (arguments[1]) {
        result = context.fn([...arguments[1]]) // 调用赋值的函数
    }
    delete context.fn
    return result
}
</code></pre>
<h3 id="4-bind">4、<strong>bind</strong></h3>
<pre><code>Function.prototype.myBind = function(context) {
    if (typeof this !== 'function') {
        throw new TypeError('error')
    }
    // 获取参数
    let args = [...arguments].slice(1) // 第一个是对象
    context.fn = this // 调用对象
    return function Fn() {
            return fn.apply(this instanceof Fn ? this : context, args.concat(...arguments)) }
}
</code></pre>
<h3 id="三-总结">三, <strong>总结</strong></h3>
<pre><code>bind和call与apply的区别是不会立即调用函数，常用于改变回调函数的参数，bind的参数传递方式和call一样
</code></pre>
]]></content>
    </entry>
</feed>